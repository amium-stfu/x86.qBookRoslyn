using System;
using System.Collections.Generic;

namespace QB.Automation
{
    public enum SignalType { Sin, Cos, Sawtooth, Rectangle, Triangle, Noise, Pwm };

    /// <summary>
    /// Creates a Simulation Object
    /// The Simulation-Object delays the input (@in) by 1 second and passes it to the output (@out)
    /// </summary>
    public class Simulation : TimerModule
    {
        //  public Signal In = new Signal("In", 0, "", "red");
        //  public Signal Out = new Signal("Out", 0, "", "blue");

        // Timer _timer;

        public Simulation(string name, string unit = "", int interval = 10) : base(name)
        {
            Unit = unit;
            Color = System.Drawing.Color.DarkViolet;
            Set = null;
            Out.Name = name + ".Out";
            Out.Unit = "%";
            Out.Color = System.Drawing.Color.Blue;

            _timer.Interval = interval;

            Run();
        }

        Queue<double> _queue = new Queue<double>();
        double lastOut = 0;

        public override void Run()
        {
            Value = 0;
            Out.Value = 0;
            base.Run();
            _timer.OnElapsed -= _Elapsed;
            _timer.OnElapsed += _Elapsed;
        }

        public override void Destroy()
        {
            _timer.OnElapsed -= _Elapsed;
            base.Destroy();

        }

        public void _Elapsed(Timer s, TimerEventArgs ea)
        {
            if (!double.IsNaN(Value))
                _queue.Enqueue(Value);

            double _out = 0;
            if (_queue.Count > 100)
                _out = _queue.Dequeue();

            Out.Value = (lastOut * 50 + _out) / 51;
            lastOut = Out.Value;
        }
    }


    /// <summary>
    /// Signalgenerator
    /// </summary>
    public class SignalGenerator : TimerModule
    {
        //    Timer _timer;

        //SCAN internal static List<SignalGen> SignalGenList = new List<SignalGen>();

        /// <summary>
        /// Out (autogenerated Signal)
        /// </summary>
        //   public Signal Out = new Signal("Out", 0, "", "blue");

        /// <summary>
        /// SignalType (default = SignalType.Sin)
        /// </summary>
        public SignalType SignalType = SignalType.Sin;


        Random _random = new Random((int)DateTime.Now.Ticks);


        /// <summary>
        /// Starts/Resets the Signal
        /// </summary>
        /// <param name="name">text/label</param>
        /// <param name="signalType">signalType (enum SignalType)</param>
        /// <param name="period">period (milliseconds)</param>
        /// <param name="amplitude">amplidude</param>
        /// <param name="offset">offset</param>
        public SignalGenerator(string name, SignalType signalType = SignalType.Sin, int period = 10 * 1000, double min = 0, double max = 100) : base(name)
        {
            _timer.Interval = 10;
            //SCAN    lock (SignalGenList)
            {
                SignalType = signalType;
                // SignalGenList.Add(this);
                Period = period;
                Min = min;
                Max = max;
                Run();
                // Start(periode, amplitude);
            }
        }

        public void _Elapsed(Timer t, TimerEventArgs ea)
        {
            // base.Elapsed(s);

            //SCANlock (SignalGenList)
            {
                //SCAN   foreach (var sg in SignalGenList)
                SignalGenerator sg = this;//SCAN 
                {
                    try
                    {
                        sg.x = (double)(DateTime.Now.Ticks - sg.startTicks) / (double)TimeSpan.TicksPerMillisecond;// / 1000.0;

                        int elapsedPeriodes = 0;
                        switch (sg.SignalType)
                        {
                            case SignalType.Sin:
                                sg.Out.Value = Min + (Max - Min) / 2 + Math.Sin(sg.x * 20 / Math.PI / sg.Period) * (Max - Min) / 2;
                                break;
                            case SignalType.Cos:
                                sg.Out.Value = Min + (Max - Min) / 2 + Math.Cos(sg.x * 20 / Math.PI / sg.Period) * (Max - Min) / 2;
                                break;
                            case SignalType.Rectangle:
                                elapsedPeriodes = (int)(sg.x / sg.Period);
                                sg.Out.Value = Min + ((((sg.x - elapsedPeriodes * sg.Period)) < sg.Period / 2) ? (Max - Min) : 0);
                                break;
                            case SignalType.Sawtooth:
                                elapsedPeriodes = (int)(sg.x / sg.Period);
                                sg.Out.Value = Min + (sg.x - elapsedPeriodes * sg.Period) / sg.Period * (Max - Min);
                                break;
                            case SignalType.Triangle:
                                elapsedPeriodes = (int)(sg.x / sg.Period);
                                double periodePercent = (sg.x - elapsedPeriodes * sg.Period) / sg.Period;
                                if (periodePercent < 0.5)
                                    sg.Out.Value = Min + (sg.x - elapsedPeriodes * sg.Period) / sg.Period * (Max - Min) * 2;
                                else
                                    sg.Out.Value = Min + 2 * (Max - Min) - (sg.x - elapsedPeriodes * sg.Period) / sg.Period * (Max - Min) * 2;
                                break;
                            case SignalType.Noise:
                                sg.Out.Value = Min + _random.NextDouble() * (Max - Min);
                                break;
                            case SignalType.Pwm:
                                sg.Period = 1000.0 / sg.Set.Value;
                                break;
                        }
                    }
                    catch (Exception ex)
                    {
                        QB.Logger.Error("#EX in SinglanGen: " + ex.Message);
                    }
                }
            }
        }


        public override void Run()
        {
            base.Run();
            this.startTicks = DateTime.Now.Ticks;
            Out.Value = 0;
            _timer.OnElapsed -= _Elapsed;
            _timer.OnElapsed += _Elapsed;
        }

        public override void Destroy()
        {
            _timer.OnElapsed -= _Elapsed;
            base.Destroy();
        }


        private long startTicks = 0;
        /*
        
        public void Start(double periode = 1.0, double amplitude = 1.0)
        {
            this.Periode = periode;
            this.Amplitude = amplitude;
            Out.Value = 0;
            reset();
        }
        */
        double x = 0; //current x

        /// <summary>
        /// Period (default = 60000 milliseconds)
        /// </summary>
        public double Period { get; set; } = 60000;
        /// <summary>
        /// Amplitude (default = 1.0)
        /// </summary>
        public double Min { get; set; } = 1.0;
        /// <summary>
        /// Offset (default = 0.0)
        /// </summary>
        public double Max { get; set; } = 0.0;
    }


    public class DemoSignal : Module
    {

        public Module Tau = new Module("Tau");
        public Module UpdateRate = new Module("UpdateRate");
        public Module NoiseStrength = new Module("NoiseStrength");
        public Module NoiseFrequence = new Module("NoiseFrequence");
        public Module Noise = new Module("ValueNoise");
        public Module Frequence = new Module("ValueFrequence");



        //tau simulation parameter
        private double start = 0;
        private double time = 0;
        private double range = 0;
        private double newSet = 0;

        //Sample simulation parameter
        private int randomCounter = 0;
        public int RandomValueAt = -1;
        public int RandomRange = 100;

        //Noise parameter
        private int noiseCounter = 1;
        private double NoiseValue;
        private int noisePeak = 0;

        //rate
        DateTime startTime;
        TimeSpan duration;

        private QB.Timer timer = new QB.Timer("timer", 100);

        public string Name;

        public DemoSignal(string name, string text, string unit) : base(name)
        {
            Text = text;
            Unit = unit;
            startTime = DateTime.Now;

            Value = 0;
            Out.Value = 0;
            Set.Value = 0;
            time = 0;

            Out.Text = text + ".Out";
            Set.Text = text + ".Set";
            Set.Unit = unit;

            NoiseFrequence.Value = 1;
            NoiseStrength.Set.Value = 0;
            NoiseFrequence.Set.Value = 1;
            NoiseStrength.Value = 0;

            Tau.Value = 0.1;
            Tau.Set.Value = 0.1;

            timer.OnElapsed = (t, ea) => idle(t, ea);
            timer.Run();
        }

        private void idle(QB.Timer t, TimerEventArgs ea)
        {
            addNoise();
            generate();

            Tau.Value = Tau.Set.Value;
            NoiseStrength.Value = NoiseStrength.Set.Value;
            NoiseFrequence.Value = NoiseFrequence.Set.Value;

        }

        public void generate()
        {

            duration = DateTime.Now - startTime;
            double rate = duration.TotalSeconds;
            //	if (Out.Value != Set.Value) {
            if (newSet != Set.Value)
            {
                newSet = Set.Value;
                range = Set.Value - Value;
                start = Value;
                time = 0;
            }
            //calc Value
            if (time < 10 * Tau.Value)
            {
                time = time + rate;
                var t1 = time * -1;
                var t2 = t1 / Tau.Value;
                var et = 1 - Math.Exp(t2);
                var d = range * et;
                Value = start + d + Noise.Value;

            }
            else
            {
                Value = Set.Value + Noise.Value;
            }
            startTime = DateTime.Now;
        }

        private void addNoise()
        {
            double nf = NoiseFrequence.Value;
            noiseCounter++;
            if (noiseCounter > nf)
                noiseCounter = 0;
            if (noiseCounter == nf)
            {
                var r = new Random();
                double n = r.Next(-100, 100);

                double rstl = n / 100 * NoiseStrength.Value + noisePeak;
                Noise.Value = rstl;
                noiseCounter = 0;
                noisePeak = 0;
            }
            else
            {
                Noise.Value = 0 + noisePeak;
                noisePeak = 0;
            }
        }

        public void AddPeak()
        {
            var r = new Random();
            noisePeak = r.Next(-500, 500);
        }

    }
}